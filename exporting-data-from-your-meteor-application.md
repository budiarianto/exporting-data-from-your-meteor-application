### Getting Started

Before we write any code to get data out of our application, let's get a few prerequisites installed and out of the way.

First, this recipe relies on a few NPM packages that are _not_ available via [Atmosphere](http://atmospherejs.com). While we can setup a local Meteor package and import these ourselves, it's much easier to use the `meteorhacks:npm` package to quickly and easily add them.

To install the `meteorhacks:npm` package, hop over to your terminal and from within your project's directory run:

<p class="block-header">Terminal</p>

```.lang-bash
meteor add meteorhacks:npm
```

This will fetch a copy of the package from Atmosphere and install it for you.

Next, we need to get our packages installed via NPM. If everything went well installing the `meteorhacks:npm` package, you should see a new `packages.json` file in your project's root folder. Open it up and add the following:

<p class="block-header">packages.json</p>
```.lang-javascript
{
  "jszip": "2.4.0",
  "xmlbuilder": "2.4.4",
  "fast-csv": "0.5.3"
}
```

Here, we're adding three dependencies: [JSZip](https://www.npmjs.org/package/jszip) (what we'll use to create our zip file), [XML Builder](https://www.npmjs.org/package/xmlbuilder) (what we'll use to export an XML file), and [Fast CSV](https://www.npmjs.org/package/fast-csv) (what we'll use to export a CSV file). Once you've updated your `packages.json` file, save it and each package will be installed.

Before we dig in, we need one more package from Atmosphere: `pfafman:filesaver`. This Meteor package will give us access to [FileSaver.js](https://github.com/eligrey/FileSaver.js) on the client so we can actually _download_ our .zip file. To get installed, hop into your terminal and run:

<p class="block-header">Terminal</p>

```.lang-bash
meteor add pfafman:filesaver
```

Wonderful! If all went as planned, we should have our dependencies locked and loaded and we can move into getting our data exported.

<div class="note">
<h3>A quick note</h3>
<p>If you're following along with <a href="https://github.com/themeteorchef/exporting-data-from-your-meteor-application">the source code on GitHub</a>, you'll notice that this recipe has a handful of templates, routes, and directories pre-defined for you. You're welcome to organize these however you'd like in your own application, however, the remainder of this recipe will focus on walking through how things are organized <a href="https://github.com/themeteorchef/exporting-data-from-your-meteor-application">in the example code</a>.</p>
</div>

### Our Server Side Method

Although our goal will be to get our data exported from the client by the time we're finished, the meat of our export will be handled on the server. To get started, we'll want to create a file in our `/server` directory called `export.coffee`. This is where we'll store our `exportData` method that we can call from the client.

The first thing we want to do in our new `/server/export.coffee` file is to require our NPM packages that we added a little bit ago. To keep things simple, let's add these to the top of our file:

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
jsZip      = Meteor.npmRequire 'jszip'
xmlBuilder = Meteor.npmRequire 'xmlbuilder'
fastCsv    = Meteor.npmRequire 'fast-csv'
```
Here, we're making use of the `Meteor.npmRequire` method given to us by the `meteorhacks:npm` package that we installed earlier. We're setting each require up as a variable so that we can use it later to call on each package's functions.

Next, we need to scope out our actual method. Because we're going to be pull from the database in our method, we need to have some sort of unique identifier to ensure that we're pulling out only the data that we want (e.g. we only want to get Peter's data and not the data for _all_ users). To handle this, we'll pass Peter's user ID (generated by Meteor) as a variable called `userId` to our `exportData` method.

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
Meteor.methods(
  exportData: (userId) ->
    # Make sure to "Check" the userId variable.
    check(userId,String)
    # We'll handle our actual export here.
)
```

**Note:** We're making use of the [Meteor Check package](https://docs.meteor.com/#/full/check) so that we can verify the data being sent from the client actually matches the expected pattern on the server. This is a good practice to pick up as it ensures only the data you want is getting into the database. Here, we're only passing over a single string, so we test the variable against the `String` pattern.

### Setting up our .zip file

Now that we've got the skeleton of our method outlined, we need to get our .zip file initialized so we can start adding data to it. First, we need to create an instance of JSZip using the variable we set the require to up above (`jsZip`).

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
zip = new jsZip()
```

**Note:** We're creating our instance of JSZip (`new jsZip()`) using the `jsZip` variable we set above. This is telling our script to create a new instance of the function we _required_ via NPM.

Great! With this in place, we now have an actual .zip file where we can send our data. While it's entirely optional, JSZip also gives us the ability to create folders _within_ our .zip file. If your application has a lot of data being exported, adding folders is a nice touch of UX to keep things neat and tidy for your users.

Creating a folder is nice and simple. For our recipe, we're going to create an `assets` directory in our .zip where we'll store some files to use with our .html export later on in the recipe. Here's how we do it:

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
assetsFolder  = zip.folder 'assets'
```
Awesome. Now we have a directory ready to go for later. Let's move on to getting the Peter's data out of our database.

### Retrieving Peter's Data
Fortunately for us, Peter's profile on Blerg is pretty simple. We have to make sure he can export four things: his profile information, his list of friends, comments posted by friends, and posts by Peter.

For each collection (except for `Meteor.users`, we're going to call the `Collection.find()` method and end with the `.fetch()` method. We're making use of `.fetch()` here because it will transform our MongoDB cursor into an array of objects that we can loop through.

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
getUser     = Meteor.users.findOne({"_id": userId}, {fields: {"profile.name": 1, "profile.photo": 1, "profile.biography": 1, "profile.location": 1, "profile.career": 1}})
getFriends  = Friends.find({"owner": userId}, {fields: {"_id": 1, "photo": 1, "name": 1}}).fetch()
getComments = Comments.find({"owner": userId}, {fields: {"_id": 1, "avatar": 1, "commenterName": 1, "commentDate": 1, "commentContent": 1}}).fetch()
getPosts    = Posts.find({"owner": userId}, {fields: {"_id": 1, "text": 1, "name": 1, "date": 1}}).fetch()
```

**Note:** To keep things efficient, you'll notice that each `.findOne` or `.find()` method is using a `{fields: {"key": 0/1}}` object (known as a [Projection](http://docs.mongodb.org/manual/tutorial/project-fields-from-query-results/#projection) in MongoDB land) to specify exactly what data we want to get out of the database. This is wise because without it, we end up pulling _every single field_ for that collection. If this is your intent that's ok, but in many instances we only want to pull specific pieces of data. The `0/1` in the example above is an alternative way of specifying `true` or `false`.

### Exporting Peter's Friends as a CSV File

Alright, we're ready to get some data exported from the application. A convention that we're going to introduce for the sake of cleanliness is wrapping each of our exports in a function. You don't _have_ to do this, however, it keeps everything cleaner and easy to see. This helps with code blurring together and makes it easy to control when each of our exports ultimately occurs (a biggie if you have a lot of data). Let's define our function for exporting friends as a .csv file `exportFriendsAsCsv`:

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
exportFriendsAsCsv = ->
  # Our exporting code will go here.
```

Now, let's fill in our function. Here, we'll be making use of the [Fast CSV](https://www.npmjs.org/package/fast-csv) package we added along with our other NPM packages. First, we need to create an instance of Fast CSV:

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
exportFriendsAsCsv = ->
 csv = fastCsv
```

Again, we're setting a variable for our instance `csv` equal to the variable we set our NPM require to `fastCsv`. You'll notice that we're not calling the variable as a function (e.g. `fastCsv()`). This is because when Fast CSV is called as a function, it returns a transform stream (admittedly, this is a concept used in Node.js that I'm not terribly familiar with):
> If you use fast-csv as a function it returns a transform stream that can be piped into.

Instead, we just want to gain access to Fast CSV's methods for handling our data. In our case, we want to simply write to a string, so we'll use Fast CSV's `.writeToString()` method. In it, we pass our data (the `.writeToString()` method accepts an array of objects, or, what we're returning from our `getFriends` variable up above). Let's look at the entire setup and then step through it:

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
csv.writeToString(getFriends,
  {headers: true},
  (error,data) ->
    if error
      console.log error
    else
      zip.file('friends.csv', data)
)
```

We have a few things going on here. The first is that we're passing our `getFriends` variable as the first argument to the `.writeToString()` method. This is what Fast CSV will actually convert into a .csv file. Next, we're passing an options object with the key `headers` set to `true`. This tells Fast CSV that we want our first row to be column headers in our .csv file. This is pretty simple, so if you need something a bit more verbose, check out the [Fast CSV documentation](https://www.npmjs.org/package/fast-csv) for more options.

Finally, we have a callback function that's returning either an `error` or `data` variable (this pattern should be familiar as `error` and `data` or `response` are common arguments in callback functions).

Here, we're making use of the `data` argument as that contains our CSV string. We take the new string and then pass it to `zip.file('friends.csv', data)`. As you may have guessed, this is adding a file to our .zip file that we created earlier. By calling the `.file()` method, we're telling JS Zip to add a single file to the _root_ of our .zip (recall we made a folder, too, but we'll be using that later).

Finally, we have a callback function that's returning either an `error` or `data` variable (this pattern should be familiar as `error` and `data` or `response` are common arguments in callback functions).

Here, we're making use of the `data` argument as that contains our CSV string. We take the new string and then pass it to `zip.file('friends.csv', data)`. As you may have guessed, this is adding a file to our .zip file that we created earlier. By calling the `.file()` method, we're telling JS Zip to add a single file to the _root_ of our .zip (recall we made a folder, too, but we'll be using that later).

Now, when Peter open's up his .zip file later, he'll see a file called `friends.csv` inside that contains a list of all of his friends! Rad.

### Exporting Peter's Profile as an XML File

The next thing we want to do is get Peter's entire profile (_all_ of his data) exported as an XML file. Having this will be handy if Peter decides to leave our service and come back later as it makes importing his data much easier.

<div class="note">
<h3>A quick note</h3>
<p>This part is a bit repetitive, so we're going to look at just a few examples here. If you want to see the full monty, make sure to <a href="https://github.com/themeteorchef/exporting-data-from-your-meteor-application">check out the source on GitHub</a>.</p>
</div>

The first thing we need to do is get our XML document setup. For this, we'll use XML Builder's `.create()` method to get setup.

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
profile = xmlBuilder.create('profile')
```

Ultimately, this creates an XML object for us called profile:

``` .lang-markup
<profile>
  # The rest of our XML data will go in here.
</profile>
```

For each successive block or nested piece of data in our XML document, we'll be making use of XML Builder's `.ele` method (short for "element"). It's important to pay attention here as the nesting part can be a bit overwhelming at first. To keep things easy to understand, we can assign our "parent" elements as variables and then nest our data using them ([wat](http://i3.kym-cdn.com/photos/images/newsfeed/000/173/576/Wat8.jpg)).

<p class="block-header">/server/export.coffee</p>
```.lang-coffeescript
userData = profile.ele('user')

userData.ele('name', getUser.profile.name)
userData.ele('photo', getUser.profile.photo)
userData.ele('biography', getUser.profile.biography)
userData.ele('location', getUser.profile.location)
userData.ele('career', getUser.profile.career)
```

We're doing two things here: first, we're creating an element called `<user></user>` to store Peter's profile information and setting it to a variable called `userData`. Next, we're nesting the actual data from Peter's profile into that object. A tad confusing, no? Here's the XML this code would translate into:

``` .lang-markup
<profile>
  <user>
    <name>Peter Venkman</name>
    <photo>URL of Peter's Photo</photo>
    <biography>Peter's biography</biography>
    <location>Peter's location</location>
    <career>Peter's career</location>
  </user>
</profile>
```

Phew. That _should_ make better sense now. This is what I meant by repetitive. It's somewhat tedious to get this data formatted as XML, however, things get a bit easier when we have data we can loop through. Let's take a look at how we'd export Peter's friends:

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
friendsData = profile.ele('friends')

for friend in getFriends
  friendData = friendsData.ele('friend')
  friendData.ele('name', friend.name)
  friendData.ele('photo', friend.photo)
```

In this snippet, we're again creating an element that's nested _inside_ of our parent `<profile>` element called `<friends></friends>` and then looping through each friend and outputting a `<friend></friend>` element with _it's own_ nested data. [My oh my](http://inception.davepedu.com/)! Alas, this gets us Peter's list of friends nestled gently in our XML data tree.

I'll spare you the drama for the rest of our data, as our Comments and Posts data uses the same looping pattern as Friends. [Check out the source on GitHub](https://github.com/themeteorchef/exporting-data-from-your-meteor-application) to see this in action. There's one last step for XML: getting the correct formatting and adding it to our .zip.

In order to let XML Builder know that we've finished our XML document and we'd like it to return a string, we need to make use of the `.end()` method.

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
profileXmlString = profile.end({pretty: true})
```

Here, we're setting a variable called `profileXmlString` to the results of calling the `.end()` method. You'll notice that we're passing an option's object with one option `pretty: true`. This tells XML Builder that we want our XML string to be returned looking "pretty" with indentation (as opposed to one massive minified string). This is optional, but is nice for verifying that data is exporting as you'd expect.

Finally, we want to add our XML string to our .zip file:

<p class="block-header">/server/export.coffee</p>
```.lang-coffeescript
zip.file('profile.xml', profileXmlString)
```

Blammo! XML-based profile = added to zip. Onto our last export: HTML.

### Exporting Peter's Profile as an HTML File

I'll preface by saying there's _probably_ a better way to export HTML than this. For now, it works well enough and gives us a clear picture of what is being exported and how. If you have any thoughts on improving this, leave a comment below and we can chat. Alright, sufficiently underwhelmed? Let's rock.

Remember earlier when we made a folder within our .zip called `assets`? This is where it shines. As a nice UX touch for Peter, we want to make sure that the HTML export of his profile still "works" to some degree. We want to retain roughly the same style of the profile as it appears in our demo, as well as the ability to click on the tabs that Peter uses to flip between his own Posts and Comments from his friends.

To do this, we can make reference to some remote files that contain a simplified version of our CSS and JavaScript that control the profile.

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
exportCss = Assets.getText("export/style.css")
exportJs  = Assets.getText("export/bootstrap.js")
```

What we're accomplishing here is importing a stylesheet file for our HTML export as well as a simplified copy of `bootstrap.js` (the library we're using to gain the toggleable tab functionality in our demo). More specifically, we're making use of Meteor's `Assets.getText()` function to pull in our `style.css` and `bootstrap.js` files from our server. The only question is _where_?

The code above may lead you to believe that we have a directory called `/export` in the root of our project. If you dig around, though, you won't find it. That's because the `Assets` function looks at your path _relative_ to the `/private` folder. This means that in reality, our `style.css` and `bootstrap.js` files are located at `/private/export` in our file tree. As [explained in the Meteor documentation](https://docs.meteor.com/#/full/assets), the `.getText()` method helps you:

> Retrieve the contents of the static server asset as a UTF8-encoded string.

Nifty, eh?

Alright, last step for this part is to add these files (or rather, their now stringified counterparts) to our .zip file:

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
assetsFolder.file('style.css', exportCss)
assetsFolder.file('bootstrap.js', exportJs)
```

How's that for a resolution?! We bring our friend `assetsFolder` back to the party and add our CSS and JavaScript files/strings using the `.file()` method. Notice, by calling `.file()` on  the `assetsFolder` variable, we're essentially saying `zip.folder('assets').file('<our file(s) here>')`.

Okay, now for the frustrating part. Getting the _actual_ HTML out of our app is somewhat tedious. Because our HTML is just text, we can build our file manually by concatenating plain strings that contain our HTML. Take a look at this:

<p class="block-header">/server/export.coffee</p>
```.lang-coffeescript
head = "
  <head>
    <title>Blerg | Data Export</title>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' href='assets/style.css'>
  </head>
"
scripts = "
  <script src='https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js'></script>
  <script src='assets/bootstrap.js'></script>
"
header = "<html>#{head}<body>"
footer = "#{scripts}</body></html>"
```
Not the most fun you'll ever have. Here, we're building out our HTML as a series of strings that correspond to a part of our HTML document. The code is pretty self explanatory. We break up each piece into a chunk of HTML and then, in the `header` and `footer` variables here, use concatenation to include each respective piece. If you're not terribly hip with CoffeeScript, the `#{variableName}` convention is something know as string interpolation. This allows us to include the contents of a variable inline without using a bunch of `+ variable +` action. It's a _serious_ time and headache saver ([Ben says it best](https://medium.com/@bengottabides/in-defense-of-coffeescript-9baa1ad094d1)).

The only thing to point out here as important is that inside of our `head` variable (not `header`), we're making reference to the stylesheet that we added to our .zip file above. Notice that the path to the file is set to where we expect it to be _after_ we export it, meaning, we expect it to be in the `/assets` directory in our .zip file.

Exporting the rest of our HTML happens in the same fashion, so to save time I'll leave it out here and yet again direct you to [take a peek at the source on GitHub](https://github.com/themeteorchef/exporting-data-from-your-meteor-application).

There is one other part that may be useful to see: looping through data and spitting out HTML. This comes up in the sidebar of Peter's profile where we display his list of friends. Here's how we handle that:

<p class="block-header">/server/export.coffee</p>
```.lang-coffeescript
friendsList = "<ul>"
for friend in getFriends
  friendsList += "<li><img src='#{friend.photo}' class='img-responsive' alt='#{friend.name}'></li>"
friendsList += "</ul>"
```

We're using a very similar convention to what we did above, however, this time we're incorporating a `for` loop. The trick to getting our HTML output correctly is creating a string set to a variable `friendsList` with some opening HTML and then _appending_ to that string for each successive loop using the JavaScript `+=` operator. Finally, outside of the loop, we do the same to "cap" the `<ul>` with it's closing `</ul>`. One of my personal favorites </dork>.

The rest of our HTML file is handled the same up until we actually add our HTML as a file in our .zip file. This should look familiar:

<p class="block-header">/server/export.coffee</p>
``` .lang-coffeescript
htmlExportString = header + container + footer
zip.file('index.html', htmlExportString)
```

Similar to how we wrapped our XML export, here we're puling together all of our strings into a single variable `htmlExportString` and passing that to the `zip.file()` method to create a file in our .zip file's root called `index.html`. That's it for HTML and getting data out, so let's move onto the last step of exporting data from our application: sending our .zip data back to the client!

### Getting Our .zip File to the Client

_Cracks knuckles_. Alright! We're in the home stretch.

The last step is to get our .zip file off of the server and onto the client. Remember that because we wrapped each of our exports in a function, we need to make sure that we actually _call_ them. If we don't, we'll run our method and nothing will happen. This is simple:

<p class="block-header">/server/export.coffee</p>
```.lang-coffeescript
exportFriendsAsCsv()
exportProfileAsXml()
exportProfileAsHtml()
```

There are of course a number of different ways to organize and structure this, so don't take my method as gospel. Use what works best for you and your current knowledge. Okay, the last bit is to generate our .zip file and return it from our method:

<p class="block-header">/server/export.coffee</p>
```.lang-coffeescript
zip.generate({type: "base64"})
```

Before we explain what's happening here, I should note that in CoffeeScript, that last line of any function is what gets returned, meaning, you don't need to explicitly say `return <thing>` like you would with vanilla JavaScript. So, what's happening here? Very simple: we're calling the `.generate()` method on our `zip` instance from way up top in our code and passing an options object with the key `type` set to `base64`. Why?

I don't have the best answer for this as I came to this result from experimentation. [JS Zip offers a number of different _types_](http://stuk.github.io/jszip/documentation/api_jszip/generate.html) for exporting your .zip file. When I gave it a try, the first one to work without issue was `base64`. So we all understand what exactly `base64` means:

> Base64 is a group of similar binary-to-text encoding schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation. The term Base64 originates from a specific MIME content transfer encoding.

via [base64 on Wikipedia](http://en.wikipedia.org/wiki/Base64)

Mostly gibberish to me, but hey! Computers! Alright, with this last line in our `/server/export.coffee` we can finally move over to the client to handle the download portion of our export. Exciting!

### Downloading Our .zip File on the Client

Last step! Let's get this .zip off our server and onto Peter's computer. We need to call our method when Peter does something on the client. I've setup a template and route called `export` in our demo where we've fashioned a nifty "Export Data" button, but you can use whatever you'd like. Most likely, though, you'll use [template events](https://docs.meteor.com/#/full/templates_api) to make the bloop go bleep. That's what we'll show off here. We're going to watch for a click event on our `.export-data` button.

<p class="block-header">/client/controllers/authenticated/export.coffee</p>
```.lang-coffeescript
Template.export.events(
  'click .export-data': ->
    userId = Meteor.userId()
    Meteor.call('exportData', userId, (error,response)->
      if error
        console.log error.reason
      else
        # This is where we'll handle downloading our .zip file.
    )
)
```

This should look pretty familiar. Inside of our click event, we're setting the current value of `Meteor.userId()` (Peter's ID) to a variable called `userId` and then dialing up our `exportData` method on the server. Lastly, we're handling either the `error` argument if it rears its ugly head. Let's take a look at how we'll handle the download:

<p class="block-header">/client/controllers/authenticated/export.coffee</p>
```.lang-coffeescript
base64ToBlob = (base64String) ->
  byteCharacters = atob(base64String)
  byteNumbers    = new Array(byteCharacters.length)
  i              = 0
  while i < byteCharacters.length
    byteNumbers[i] = byteCharacters.charCodeAt(i)
    i++
  byteArray = new Uint8Array(byteNumbers)
  return blob = new Blob([byteArray],
    type: "zip"
  )
blob = base64ToBlob(response)
saveAs(blob, 'export.zip')
```
Woah! What is all of this?! Recall that on the server we decided to return our .zip file as a base64 string. This is fine, but in order to save it out, it needs to be converted into a [Blob object](https://developer.mozilla.org/en-US/docs/Web/API/Blob). This is because FileSaver.js, the script we'll use to handle the download, requires our data to be in this format.

The function being used to convert from base64 to Blob is not my handiwork. I discovered it [over on the oracle a.k.a. Stack Overflow](http://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript). A bit mystical, but it works!

Finally, we set the response of this function, passing in our base64 string to the `blob` variable. Last but not least, we call the `SaveAs()` function provided by FileSaver.js, passing in our `blob` variable as the first argument and a name for our .zip file as a string in the second argument (this is arbitrary and the file can be named `whatever-you-want.zip`).

That's it! We're finished. Just like in our demo, whenever Peter clicks on the "Export Data" button, our method will be called on the server, format all of his data, and download to his computer as `export.zip`. Pretty cool.

We should celebrate a bit, this was a lot of work!

<iframe width="420" height="315" src="//www.youtube.com/embed/MCqUESCoB1w" frameborder="0" allowfullscreen></iframe>

Do you feel like a champion? You should. You deserve that gold medal, sport.

### Wrap Up & Summary

Wow. What a feat. In this recipe we learned how to export data on the client as a .zip file using a server side method. We learned how to export our data as CSV, XML, and HTML files as well as how to bundle them into a .zip file. Finally, we learned how to get the .zip file off our server and onto our user, Peter's computer. High fives all around.
